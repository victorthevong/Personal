<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184 Project 3-1: Ray Tracing Part 1</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>


<body>

<h1 align="middle">CS 184: Computer Graphics and Imaging, Spring 2017</h1>
<h1 align="middle">Project 3-1: Ray Tracing </h1>
<h2 align="middle">Victor Vong, CS184-aax</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>Give a high-level overview of what you implemented in this project. Think about what you've built as a whole. Share your thoughts on what interesting things you've learned from completing the project.</p>

<p>This project focused around basic ray generation for triangle and spheres (other primitive shapes could be added). We then implemented a bounding box hierarchy (BVH) to speed up our rendering and handle images of higher quality and shape. Our attention then changed to implementing direct and indirect illumination (Global Illumination when combining both), and finally implemented adaptive sampling to avoid the problem of using a fixed (high) number of samples per pixel, and instead finding the number of samples leading to convergence in order to eliminate noise (noise generated by Monte Carlo Path tracing from previous Sections).</p>


<h2 align="middle">Section I: Ray Generation and Scene Intersection</h2>

<p>Walk through the ray generation and primitive intersection parts of the rendering pipeline.</p>

<p>In order to generate a ray, we first were asked to sample each pixel within the pixel space, some number (ns_aa) times generating a ray for each sample, then checking if the ray intersects with any primitives via tracing the ray (so that we could give the pixel the correct color via a Spectrum object representing r,g,b,a values). In order to raytrace any pixel, we had to estimate the integral of the irradiance over the pixel (the methodology discussed previously). If the number of samples was 1, we simply sampled the pixel in its direct center adding .5 to both the x and y coordinates, else we averaged the pixels. </p>

<p>For each sample, we were directed to scale from the image location (x,y) position into the image buffer space by dividing out the image buffers width and height accordingly. These scaled coordinates are then used to generate the ray (A Ray is a container or Vector3D's with an origin and direction) in order to map the camera pinhole (origin) to the pixel point within the pixel space/image buffer space.</p>

<p>In order to determine the ray's direction, the (x,y) are mapped into screen space by scaling the bottom left and bottom right of of the camera's view space. The direction vector is then taken from the screen space into the world space, by appropriate predetermined matrix multiplication. We then normalize the new direction vector and are able to finally generate the ray with the camera as the origin, a normalized direction vector. Each ray that is generated also has a min_t and max_t value which represent how close and how far the ray can be projected into our scene. We set these values to nClip and fClip (provided) which are unique to the camera. </p>

<p>The final step is to ray trace the generated ray and check for intersections with primitives in order to return a Spectrum. After we have determined all intersections of a specific pixel, we are able to average them and determine the most accurate Spectrum value for that pixel.</p>

<br>
<p>Explain the triangle intersection algorithm you implemented in your own words.</p>

<p>For the triangle intersection we used the Moller Trumbore algorithm which returned the possible t value of intersection and the barycentric coordinates b1, b2 and b3 = 1 - b1 - b2. We then could use the barycentric point in triangle test, which tested if  b1,b2 >= 0 ,b1 + b2 <= 1 and had to make sure rays t_min <= t <= t_max. If all these conditions were met then a valid triangle intersection was recorded. We finally updated the rays t_max value to be t value if a valid intersection was made. </p>

<p>Show the normal shading for a few small dae files.</p>

<br>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images_1_2/1_1.png" align="middle" width="500px"/>
        <figcaption align="middle">Spheres.</figcaption>
      </td>
      </tr>
    <br>
      <tr>
      <td>
        <img src="images_1_2/1_2.png" align="middle" width="500px"/>
        <figcaption align="middle">Empty Scene.</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="images_1_2/1_3.png" align="middle" width="500px"/>
        <figcaption align="middle">Sphere Gems.</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>

<h3 align="middle">Section II: Bounding Volume Hierarchy</h3>

<p>Walk through your BVH construction algorithm. Explain the heuristic you chose for picking the splitting point.</p>

<p>We focused primarily on creating a balanced tree to satiisfy our BVH Algorithm. We did this by creating the most even split of primitives on the left and right side. We did this by finding the longest axis our primitives centroid lies on, sorted them based on this axis and their corresponding centroid axis values, and split down the median. This happens recursively until we form our Bounding Box Heirarchy.</p>

<p>1) Number of primitives <= max_leaf_size, construct a single leaf node with all primitives and return</p>
<p>2) Else, determine longest centroid axis from centroid box, x, y, or z to split on</p>
<p>3) Sort all primitives based on this axis and their corresponding centroid values</p>
<p>4) Split directly in half and as evenly as possible between left and right children nodes until BVH is finished</p>

<p>The one drawback to this algorithm is that clusters of primitives and outliers can cause weird splits. Like a lot in the middle and one farther away. This results in a small box, and a larger box.</p>

<br>
<p>Walk through your BVH intersection algorithm.</p>

<p>There are 2 BVH intersection functions, with the only difference being one requires the closest intersection returned. For a given node, ray and intersection we simply check if the ray intersects the bounding box of the node. We check to see if the node is a leaf first and if it intersects any of its primitives. If the leaf node doesn't have intersections with its bounding box (i.e. intersection t value is outside rays min_t and max_t value) we return false. Else, we keep track of the intersection boolean value and allow for all checks to happen as we set the intersection values for each primitive. We then return true.</p>

<p>Note, if the node is not a leaf node we do this recursively throughout all children nodes and do the aforementioned algorithm</p>

<p>Show the normal shading for a few large dae files that you couldn't render without the acceleration structure.</p>

<br>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images_1_2/2_1.png" align="middle" width="500px"/>
        <figcaption align="middle">Dragon.</figcaption>
      </td>
      </tr>
    <br>
      <tr>
      <td>
        <img src="images_1_2/2_2.png" align="middle" width="500px"/>
        <figcaption align="middle">Wall-E.</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="images_1_2/2_3.png" align="middle" width="500px"/>
        <figcaption align="middle">Lucy.</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>



<h2 align="middle">Section III: Direct Illumination</h2>

<p>Walk through your implementation of the direct lighting function.</p>

<p>To start we loop over every light in the scene. For each light we take some number of samples and call SceneLight:sample_L in order to get the correct Spectrum for the light. This function also sets the direction, wi, the pdf value, and the distance from the light to the pixel (distToLight). Using the direction vector, we transform it into w_in, within the object space. We then are able to compute the BSDF via calling BSDF:f (suppose to vary for different materials in this case we focus on diffuse material only) and passing in the provided w_out and w_in values (w_out is the output direction vector in the obect space). We can then check to see if w_in.z < 0, which would mean its behind the intersection point and wont contribute to the light.</p>

<p>We then create a shadow ray, which will help us determine if the supposed ray intersects the BVH. If the shadow ray intersects then, we return black. Else, we scale the light sample via the given formulation by the BSDF and a cosine factor and divide by the pdf. This scaled value is then added to get the correct spectrum and therefore direct lighting.</p>

<br>
<p>Show some images rendered with direct illumination.</p>

<br>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images_3/bunny_64_32.png" align="middle" width="500px"/>
        <figcaption align="middle">Direct Lighting with 64 Samples and 32 Light Ray(s) in Bunny Scene.</figcaption>
      </td>
      <td>
        <img src="images_3/dragon_64_32.png" align="middle" width="500px"/>
        <figcaption align="middle">Direct Lighting with 64 Samples and 32 Light Ray(s) in Bunny Scene.</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>
<br>

<p>Focus on one particular scene (with at least one area light) and compare the noise levels in soft shadows when rendering with 1, 4, 16, and 64 light rays (the -l flag) and 1 sample per pixel (the -s flag).</p>

<p>We can see the noise level in the soft shadows of 1 Light ray and 1 sample per pixel is by far the noisest. A single light ray makes it difficult to tell that the shadow has varying darkness. 4 Light rays leads to a slightly less noisy image allowing us to see more shades of the shadow. The jump to 16 Light Rays is definitely noticable as well allowing us to see an overarching shape for the lighter shadow. However, the jump from 16 to 64 Light Rays is less noticeable as compared to the jump from 1 to 4 Light Rays, but does allow us to see the softest level of the shadow.</p>

<br>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images_3/bunny_1_1.png" align="middle" width="500px"/>
        <figcaption align="middle">Noise level in soft shadow of 1 Light Ray(s) in Bunny Scene.</figcaption>
      </td>
      <td>
        <img src="images_3/bunny_4_1.png" align="middle" width="500px"/>
        <figcaption align="middle">Noise level in soft shadow of 4 Light Ray(s) in Bunny Scene.</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="images_3/bunny_16_1.png" align="middle" width="500px"/>
        <figcaption align="middle">Noise level in soft shadow of 16 Light Ray(s) in Bunny Scene.</figcaption>
      </td>
      <td>
        <img src="images_3/bunny_64_1.png" align="middle" width="500px"/>
        <figcaption align="middle">Noise level in soft shadow of 64 Light Ray(s) in Bunny Scene.</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>

<h2 align="middle">Section IV: Indirect Illumination</h2>

<p>Walk through your implementation of the indirect lighting function.</p>

<p>We first sample the hit points BSDF via the BSDF::sample_f function to get a w_in vector in the object space and set its corresponding pdf, while getting the associated Spectrum in the process. We then compute the Spectrums illumination value via Spectrum::illum in order to get its reflectance. The Spectrum represents how much incoming radiance should be reflected in outgoing radiance. We then implement Russian Roulette using a scaled illumination value to determine if we should randomly terminate the ray and return a black Spectrum. We use a value from a random uniform distribution between [0, 1] via the coin_flip method and see if its less than 1 - termination value. If the scaled illumination value is to low we will terminate more frequently than we want, thus we scaled it by a factor of 20 and add .05 (making sure te clamp the value between 0 and 1).</p>

<p>If the ray is not terminated, we create a new ray pointing in the direction of w_in offset by some epsilon value and its depth be set to the passed in rays minus 1. The new rays depth setting is important in order to know when to stop calculating indirect illumination from ray tracing. We then calculate incoming radiance from the ray caused by both direct and indirect lighting. We then scale the value by a cosine factor and the BSDF and divide by the pdf and the termination probability. This value is then our outgoing radiance based on the formulation for indirect lighting.</p>

<br>
<p>Show some images rendered with global (direct and indirect) illumination.</p>

<br>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images_4/bunny_4global.png" align="middle" width="500px"/>
        <figcaption align="middle">Previous Bunny now with Global Lighting (Direct & Indirect).</figcaption>
      </td>
      </tr>
    <br>
      <tr>
      <td>
        <img src="images_4/spheres_4.png" align="middle" width="500px"/>
        <figcaption align="middle">Previous Spheres now with Global Lighting (Direct & Indirect).</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="images_4/bench_4.png" align="middle" width="500px"/>
        <figcaption align="middle">A Bench with Global Lighting (Direct & Indirect).</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>

<p>Pick one scene and compare rendered views first with only direct illumination, then only indirect illumination. (You'll have to edit trace_ray in your code to generate these.)</p>

<p>The only thing contributing to indirect lighting (without direct lighting) is the emitted light, thus only the light source is visible. Direct lighting is seen as usual with only the tops of the spheres with light.</p>

<br>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images_4/spheres_4_onlydirect.png" align="middle" width="500px"/>
        <figcaption align="middle">Previous Spheres now only with Direct Lighting.</figcaption>
      </td>
      <td>
        <img src="images_4/spheres_4_onlyindirect.png" align="middle" width="500px"/>
        <figcaption align="middle">Previous Spheres now only with Indirect Lighting.</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>
<br>

<p>For CBbunny.dae, compare rendered views with max_ray_depth equal to 0, 1, 2, 3, and 100 (the -m flag).</p>

<p>With max depth = 0, image looks like it does with direct lighting. As max depth increases, the image gets closer to global illumination. The biggest difference in depths is when 0 goes to 1 and 1 goes to 3. We see more light accumulate underneath the bunny. When looking at 3 to 100, it seems more red and blue are present.</p>

<br>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images_4/bunny_4_s64_m0.png" align="middle" width="500px"/>
        <figcaption align="middle">Bunny with Sampling 64, 32 Light Ray(s) and max_ray_depth = 0.</figcaption>
      </td>
      <td>
        <img src="images_4/bunny_4_s64_m1.png" align="middle" width="500px"/>
        <figcaption align="middle">Bunny with Sampling 64, 32 Light Ray(s) and max_ray_depth = 1.</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="images_4/bunny_4_s64_m2.png" align="middle" width="500px"/>
        <figcaption align="middle">Bunny with Sampling 64, 32 Light Ray(s) and max_ray_depth = 2.</figcaption>
      </td>
      <td>
        <img src="images_4/bunny_4_s64_m3.png" align="middle" width="500px"/>
        <figcaption align="middle">Bunny with Sampling 64, 32 Light Ray(s) and max_ray_depth = 3.</figcaption>
      </td>
    </tr>
  </table>
</div>
<br>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images_4/bunny_4_s64_m100.png" align="middle" width="600px"/>
        <figcaption align="middle">Bunny with Sampling 64, 32 Light Ray(s) and max_ray_depth = 100.</figcaption>
      </td>
    </tr>
    <br>
  </table>
</div>
<br>

<p>Pick one scene and compare rendered views with various sample-per-pixel rates, including at least 1, 2, 4, 8, 16, 64, and 1024. Use 4 light rays.</p>

<p>A single sample per pixel produces a large amount of noise. As we take exponential samples we decrease noise. Once we reach 1024 the noise is no longer very noticeable. Trade off was render time on the machines and possibly for industry (although parallizing must save time maybe?)</p>

<br>
<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images_4/bunny_4_s1_l4.png" align="middle" width="500px"/>
        <figcaption align="middle">Bunny with Sampling 1, 4 Light Ray(s).</figcaption>
      </td>
      <td>
        <img src="images_4/bunny_4_s2_l4.png" align="middle" width="500px"/>
        <figcaption align="middle">Bunny with Sampling 2, 4 Light Ray(s).</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="images_4/bunny_4_s4_l4.png" align="middle" width="500px"/>
        <figcaption align="middle">Bunny with Sampling 4, 4 Light Ray(s).</figcaption>
      </td>
      <td>
        <img src="images_4/bunny_4_s8_l4.png" align="middle" width="500px"/>
        <figcaption align="middle">Bunny with Sampling 8, 4 Light Ray(s).</figcaption>
      </td>
    </tr>
  </table>
</div>

<br>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images_4/bunny_4_s16_l4.png" align="middle" width="500px"/>
        <figcaption align="middle">Bunny with Sampling 16, 4 Light Ray(s).</figcaption>
      </td>
      <td>
        <img src="images_4/bunny_4_s64_l4.png" align="middle" width="500px"/>
        <figcaption align="middle">Bunny with Sampling 64, 4 Light Ray(s).</figcaption>
      </td>
    </tr>
    <br>
    <tr>
      <td>
        <img src="images_4/bunny_4_s1024_l4.png" align="middle" width="500px"/>
        <figcaption align="middle">Bunny with Sampling 1024, 4 Light Ray(s).</figcaption>
      </td>
    </tr>
  </table>
</div>

<br>

<h3 align="middle">Section V: Adaptive Sampling</h3>

<p>Walk through your implementation of the adaptive sampling.</p>

<p>With Monte Carlo path tracing we need a large number of samples to reduce the noise, but with such a alrge number of fixed samples this takes time to render. With adaptive sampling, we check if the pixel converges early (thus allowing for a more precise number of samples per pixel) and finishing rendering much quicker. Adaptive sampling allows us to periodically check if any pixel sampling has converged with some designated maxTolerance and number of samples to check after. The algorithm is as follows: </p>

<p>1) We keep track of the integral of samples illumination value and illumination value squared (s1, s2)</p>
<p>2) We calculate the mean by dividing s1 by the number of samples taken for the value and the variance by (s2 - (s1 * s1 / number of samples)) / number of samples - 1 </p>
<p>3) We then check to see if 1.96 * sqrt(variance / number of samples taken for variance) <= maxTolerance * mean</p>

<p>If it is then we say that pixel convergence has occured and return the designed averaged Spectrum values after the number of samples for convergence. Else, we continue this process until either we finish all the sampling or later convergence occurs.</p>


<br>
<p>Pick one scene and render it with the maximum number of samples per pixel at least 2048. Show a good sampling rate image with clearly visible sampling rate difference over various regions and pixels. Use 1 sample per light and at least 5 for max ray depth.</p>

<div align="middle">
  <table style="width=100%">
    <tr>
      <td>
        <img src="images_5/bunny_5.png" align="middle" width="600px"/>
        <figcaption align="middle">Bunny with Sampling 2048, Light Ray 1, and Max Ray Depth 5</figcaption>
      </td>
    </tr>
    <br>
      <tr>
      <td>
        <img src="images_5/bunny_5_rate.png" align="middle" width="600px"/>
        <figcaption align="middle">Bunny Rate with Sampling 2048, Light Ray 1, and Max Ray Depth 5</figcaption>
      </td>
    </tr>
  </table>
</div>

<br>

</body>
</html>
